//start
#include "bst.h"
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
struct bst_node {
    int val;
    struct bst_node *left;
    struct bst_node *right;
    int sizeLeft;
    int sizeRight;
};
typedef struct bst_node NODE;


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
struct bst {
    NODE *root;
    int size;
    int min;	
    int max;	
};


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
BST * bst_create(){
  BST * t = malloc(sizeof(struct bst));
  t->root = NULL;
  t->min = INT_MAX;	
  t->max = INT_MIN;	
  return t;
}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
static void free_r(NODE *r){
    if(r==NULL) return;
    free_r(r->left);
    free_r(r->right);
    free(r);
}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
void bst_free(BST * t){
    free_r(t->root);
    free(t);
}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
static NODE * insert(NODE *r, int x){
    NODE *leaf;
    if(r == NULL){
      leaf = malloc(sizeof(NODE));
      leaf->left = NULL;
      leaf->right = NULL;
      leaf->val = x;
      return leaf;
    }

    if(r->val == x)
        return r;
    if(x < r->val){
    	++r->sizeLeft;	
        r->left = insert(r->left, x);
        return r;
    }
    else {
    	++r->sizeRight;	
        r->right = insert(r->right, x);
        return r;
    }
}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
// how about an iterative version?
static NODE *insert_i(NODE *r, int x){

  return NULL;

}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
void bst_insert(BST * t, int x){
    t->root = insert(t->root, x);
	t->size++;
	if(x < (*t).min)
		(*t).min = x;
	if(x > (*t).max)
		(*t).max = x;
	
}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
int bst_contains(BST * t, int x){
    NODE *p = t->root;

    while(p != NULL){

        if(p->val == x)
            return 1;
        if(x < p->val){
            p = p->left;
        }
        else
            p = p->right;
    }
    return 0;  
}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
static int min_h(NODE *r){
  if(r==NULL)
    return -1; // should never happen!
  while(r->left != NULL)
      r = r->left;
  return r->val;
}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
static int max_h(NODE *r){
  if(r==NULL)
    return -1; // should never happen!
  while(r->right != NULL)
      r = r->right;
  return r->val;
}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
static NODE *remove_r(NODE *r, int x, int *success){
NODE   *tmp;
int sanity;

  if(r==NULL){
    *success = 0;
    return NULL;
  }
  if(r->val == x){
    *success = 1;

    if(r->left == NULL){
        tmp = r->right;
        free(r);
        return tmp;
    }
    if(r->right == NULL){
        tmp = r->left;
        free(r);
        return tmp;
    }
    // if we get here, r has two children
    r->val = min_h(r->right);
    r->right = remove_r(r->right, r->val, &sanity);
    if(!sanity)
        printf("ERROR:  remove() failed to delete promoted value?\n");
    return r;
  }
  if(x < r->val){
    r->left = remove_r(r->left, x, success);
    (*r).sizeLeft--;
  }
  else {
    r->right = remove_r(r->right, x, success);
    (*r).sizeRight--;
  }
  return r;

}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
int bst_remove(BST * t, int x){
    int success;
    t->root = remove_r(t->root, x, &success);
	if(success != 0){
		(*t).size--;
		if(x == (*t).min){
			(*t).min = min_h((*t).root);
		}
		if(x == (*t).max){
			(*t).max = max_h((*t).root);
		}
	}
    return success;
}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
static int size(NODE *r){

    if(r==NULL){
     return 0;
    }
    return size(r->left) + size(r->right) + 1;
}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
int bst_size(BST * t){
   return t->size;
}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
static int height(NODE *r){
    int leftH;
    int rightH;

    if(r==NULL){
    	return -1;
    } 

    leftH = height((*r).left);
    rightH = height((*r).right);
    return 1 + (leftH > rightH ? leftH : rightH);

}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
int bst_height(BST * t){
    return height(t->root);

}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
int bst_min(BST * t){
    return t->min;
}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
int bst_max(BST * t){
    return t->max;
}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
static void indent(int m){
    int i;
    for(i=0; i<m; i++)
        printf("-");
}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
static void inorder(NODE *r){
  if(r==NULL) return;
  inorder(r->left);
  printf("[%d]\n", r->val);
  inorder(r->right);

}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
void bst_inorder(BST * t){

  printf("========BEGIN INORDER============\n");
  inorder(t->root);
  printf("=========END INORDER============\n");

}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
static void preorder(NODE *r, int margin){
  if(r==NULL) {
    indent(margin);
    printf("NULL \n");
  } else {
    indent(margin);
    printf("%d\n", r->val);
    preorder(r->left, margin+3);
    preorder(r->right, margin+3);
  }
}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
void bst_preorder(BST * t){

  printf("========BEGIN PREORDER============\n");
  preorder(t->root, 0);
  printf("=========END PREORDER============\n");

}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
/* 
 * Complete the (recursive) helper function for the post-order traversal.
 * Remember: the indentation needs to be proportional to the height of the node!
 */
static void postorder(NODE *r, int margin){
    /* FILL IN FUNCTION */
}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
// indentation is proportional to depth of node being printed
//   depth is #hops from root.
void bst_postorder(BST * t){

  printf("========BEGIN POSTORDER============\n");
  postorder(t->root, 0);
  printf("=========END POSTORDER============\n");

}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
/* 
 * Write the (recursive) helper function from_arr, used by
 * bst_from_sorted_arr(...). The function must return a sub-tree that is
 * perfectly balanced, given a sorted array of elements a.
 */
static NODE * from_arr(int *a, int n){
	int m;
	NODE *root;

	if(n <= 0) return NULL;
	m = n/2;
	root = malloc(sizeof(NODE));
	root->val = a[m];
	root->left = from_arr(a, m);
	root->right = from_arr(&(a[m+1]), n-(m+1));
	return root;

}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
BST * bst_from_sorted_arr(int *a, int n){

  BST * t = bst_create();

  t->root = from_arr(a, n);

  return t;
}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
void helper_bst_to_array(NODE *r, int *arr){
   static int counter = 0;
    if(r == NULL){
    	return;
    }

    helper_bst_to_array((*r).left,arr);

    arr[counter] = (*r).val;
 
    counter++;
    helper_bst_to_array((*r).right,arr);	
}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
int * bst_to_array(BST *t){
	int n = bst_size(t);
	int *arr = malloc(sizeof(int) * n);
	helper_bst_to_array((*t).root, arr);

	return arr;
}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
int bst_get_ith(BST *t, int i){
  int ith_num = -1;

  if ((*t).root){
    NODE *p = (*t).root;

    while (p){
      if (((*p).sizeLeft + 1) == i){
        ith_num = (*p).val;
        break;
      }
      else if (i > (*p).sizeLeft){
        i = i - ((*p).sizeLeft + 1);
        p = (*p).right;
      }
      else {
        p = (*p).left;
      }
    }
  }

  return ith_num;
}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
int helper_get_nearest(NODE *r, int a, NODE *targ){
	if(r == NULL){
		return (*targ).val;
	}

	if((*r).val == a){
		return (*r).val;
	}
	
	if(targ == NULL){
		targ = r;
	}

	if(abs((*targ).val - a) > abs((*r).val - a)){
		targ = r;
	}

	if((*r).val > a){
		return helper_get_nearest((*r).left, a, targ);
	}

	else{
		return helper_get_nearest((*r).right, a, targ);
	}
}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
int bst_get_nearest(BST *t, int x){
	if((*t).root == NULL){
		fprintf(stderr, "\n***TREE IS EMPTY***\n");
		return -999;
	}

	NODE *targ = (*t).root;
	
	if((*t).min > x ){
		return (*t).min;
	}
	if((*t).max < x ){
		return (*t).max;	
	}
	return helper_get_nearest((*t).root, x, targ);

}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
int helper_bst_num_geq(NODE *r ,int i,int count){
    
    if(r == NULL){
        return count;
    }
    if ((*r).val == i ) {
        count++;
        return helper_bst_num_geq((*r).right, i, count);
    }

    else if((*r).val > i){
    	count = count + (*r).sizeRight + 1;
        return helper_bst_num_geq((*r).left, i, count);
    }
    else{
        return helper_bst_num_geq((*r).right, i, count);
    }
}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
int bst_num_geq(BST *t, int x){
	int count = 0;
	return helper_bst_num_geq((*t).root, x, count);
}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
static int helper_bst_num_leq(NODE *r, int x) {

	if (r == NULL){
		return 0;
	}
	if ((*r).val == x){
		return 1 + size((*r).left);
	}
	if ((*r).val < x){
		return 1 + size((*r).left) + helper_bst_num_leq((*r).right, x);
	}

	return helper_bst_num_leq((*r).left, x);
}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
int bst_num_leq(BST *t,int x) {
	if (t == NULL || (*t).root == NULL) return 0;	
	return helper_bst_num_leq((*t).root,x);
}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
int bst_num_ranges(NODE *r, int min, int max){
   if ( r == NULL ){
      return;
    }
 
   if ( min < (*r).val )
     bst_num_ranges((*r).left, min, max);
 
   if ( max > (*r).val )
     bst_num_ranges((*r).right, min, max);
}
//end